{
    "sourceFile": "app/api/chat/tools/route.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1718134076362,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1718134088836,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -43,5 +43,177 @@\n           },\n           {}\n         )\n \n-        allRouteMaps = { ...allRoute\n+        allRouteMaps = { ...allRouteMaps, ...routeMap }\n+\n+        schemaDetails.push({\n+          title: convertedSchema.info.title,\n+          description: convertedSchema.info.description,\n+          url: convertedSchema.info.server,\n+          headers: selectedTool.custom_headers,\n+          routeMap,\n+          requestInBody: convertedSchema.routes[0].requestInBody\n+        })\n+      } catch (error: any) {\n+        console.error(\"Error converting schema\", error)\n+      }\n+    }\n+\n+    const firstResponse = await openai.chat.completions.create({\n+      model: chatSettings.model as ChatCompletionCreateParamsBase[\"model\"],\n+      messages,\n+      tools: allTools.length > 0 ? allTools : undefined\n+    })\n+\n+    const message = firstResponse.choices[0].message\n+    messages.push(message)\n+    const toolCalls = message.tool_calls || []\n+\n+    if (toolCalls.length === 0) {\n+      return new Response(message.content, {\n+        headers: {\n+          \"Content-Type\": \"application/json\"\n+        }\n+      })\n+    }\n+\n+    if (toolCalls.length > 0) {\n+      for (const toolCall of toolCalls) {\n+        const functionCall = toolCall.function\n+        const functionName = functionCall.name\n+        const argumentsString = toolCall.function.arguments.trim()\n+        const parsedArgs = JSON.parse(argumentsString)\n+\n+        // Find the schema detail that contains the function name\n+        const schemaDetail = schemaDetails.find(detail =>\n+          Object.values(detail.routeMap).includes(functionName)\n+        )\n+\n+        if (!schemaDetail) {\n+          throw new Error(`Function ${functionName} not found in any schema`)\n+        }\n+\n+        const pathTemplate = Object.keys(schemaDetail.routeMap).find(\n+          key => schemaDetail.routeMap[key] === functionName\n+        )\n+\n+        if (!pathTemplate) {\n+          throw new Error(`Path for function ${functionName} not found`)\n+        }\n+\n+        const path = pathTemplate.replace(/:(\\w+)/g, (_, paramName) => {\n+          const value = parsedArgs.parameters[paramName]\n+          if (!value) {\n+            throw new Error(\n+              `Parameter ${paramName} not found for function ${functionName}`\n+            )\n+          }\n+          return encodeURIComponent(value)\n+        })\n+\n+        if (!path) {\n+          throw new Error(`Path for function ${functionName} not found`)\n+        }\n+\n+        // Determine if the request should be in the body or as a query\n+        const isRequestInBody = schemaDetail.requestInBody\n+        let data = {}\n+\n+        if (isRequestInBody) {\n+          // If the type is set to body\n+          let headers = {\n+            \"Content-Type\": \"application/json\"\n+          }\n+\n+          // Check if custom headers are set\n+          const customHeaders = schemaDetail.headers // Moved this line up to the loop\n+          // Check if custom headers are set and are of type string\n+          if (customHeaders && typeof customHeaders === \"string\") {\n+            let parsedCustomHeaders = JSON.parse(customHeaders) as Record<\n+              string,\n+              string\n+            >\n+\n+            headers = {\n+              ...headers,\n+              ...parsedCustomHeaders\n+            }\n+          }\n+\n+          const fullUrl = schemaDetail.url + path\n+\n+          const bodyContent = parsedArgs.requestBody || parsedArgs\n+\n+          const requestInit = {\n+            method: \"POST\",\n+            headers,\n+            body: JSON.stringify(bodyContent) // Use the extracted requestBody or the entire parsedArgs\n+          }\n+\n+          const response = await fetch(fullUrl, requestInit)\n+\n+          if (!response.ok) {\n+            data = {\n+              error: response.statusText\n+            }\n+          } else {\n+            data = await response.json()\n+          }\n+        } else {\n+          // If the type is set to query\n+          const queryParams = new URLSearchParams(\n+            parsedArgs.parameters\n+          ).toString()\n+          const fullUrl =\n+            schemaDetail.url + path + (queryParams ? \"?\" + queryParams : \"\")\n+\n+          let headers = {}\n+\n+          // Check if custom headers are set\n+          const customHeaders = schemaDetail.headers\n+          if (customHeaders && typeof customHeaders === \"string\") {\n+            headers = JSON.parse(customHeaders)\n+          }\n+\n+          const response = await fetch(fullUrl, {\n+            method: \"GET\",\n+            headers: headers\n+          })\n+\n+          if (!response.ok) {\n+            data = {\n+              error: response.statusText\n+            }\n+          } else {\n+            data = await response.json()\n+          }\n+        }\n+\n+        messages.push({\n+          tool_call_id: toolCall.id,\n+          role: \"tool\",\n+          name: functionName,\n+          content: JSON.stringify(data)\n+        })\n+      }\n+    }\n+\n+    const secondResponse = await openai.chat.completions.create({\n+      model: chatSettings.model as ChatCompletionCreateParamsBase[\"model\"],\n+      messages,\n+      stream: true\n+    })\n+\n+    const stream = OpenAIStream(secondResponse)\n+\n+    return new StreamingTextResponse(stream)\n+  } catch (error: any) {\n+    console.error(error)\n+    const errorMessage = error.error?.message || \"An unexpected error occurred\"\n+    const errorCode = error.status || 500\n+    return new Response(JSON.stringify({ message: errorMessage }), {\n+      status: errorCode\n+    })\n+  }\n+}\n+\n"
                }
            ],
            "date": 1718134076362,
            "name": "Commit-0",
            "content": "import { openapiToFunctions } from \"@/lib/openapi-conversion\"\nimport { checkApiKey, getServerProfile } from \"@/lib/server/server-chat-helpers\"\nimport { Tables } from \"@/supabase/types\"\nimport { ChatSettings } from \"@/types\"\nimport { OpenAIStream, StreamingTextResponse } from \"ai\"\nimport OpenAI from \"openai\"\nimport { ChatCompletionCreateParamsBase } from \"openai/resources/chat/completions.mjs\"\n\nexport async function POST(request: Request) {\n  const json = await request.json()\n  const { chatSettings, messages, selectedTools } = json as {\n    chatSettings: ChatSettings\n    messages: any[]\n    selectedTools: Tables<\"tools\">[]\n  }\n\n  try {\n    const profile = await getServerProfile()\n\n    checkApiKey(profile.openai_api_key, \"OpenAI\")\n\n    const openai = new OpenAI({\n      apiKey: profile.openai_api_key || \"\",\n      organization: profile.openai_organization_id\n    })\n\n    let allTools: OpenAI.Chat.Completions.ChatCompletionTool[] = []\n    let allRouteMaps = {}\n    let schemaDetails = []\n\n    for (const selectedTool of selectedTools) {\n      try {\n        const convertedSchema = await openapiToFunctions(\n          JSON.parse(selectedTool.schema as string)\n        )\n        const tools = convertedSchema.functions || []\n        allTools = allTools.concat(tools)\n\n        const routeMap = convertedSchema.routes.reduce(\n          (map: Record<string, string>, route) => {\n            map[route.path.replace(/{(\\w+)}/g, \":$1\")] = route.operationId\n            return map\n          },\n          {}\n        )\n\n        allRouteMaps = { ...allRoute\n"
        }
    ]
}